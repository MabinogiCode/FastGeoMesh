# ?? Enhanced GitHub Actions workflow for FastGeoMesh .NET 8
# Optimized for performance and automatic code formatting

name: 'CI/CD Optimized'

on:
  push:
    branches: [ main, develop, 'feature/**', 'chore/**' ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_DETERMINISTIC_SOURCE_PATHS: true
  DOTNET_NOLOGO: true

jobs:
  # Job 1: Build with automatic formatting
  build:
    name: '?? Build & Format'
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
    
    steps:
      - name: '?? Checkout'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Required for auto-formatting commits
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: '?? Setup .NET'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          
      - name: '?? Cache .NET packages'
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-
            
      - name: '?? Restore dependencies'
        run: dotnet restore --locked-mode
        
      - name: '?? Build solution'
        run: |
          dotnet build --no-restore --configuration Release \
            /p:TreatWarningsAsErrors=false \
            /p:ContinuousIntegrationBuild=true \
            /p:Deterministic=true \
            /p:RunAnalyzersDuringBuild=false
            
      - name: '?? Auto-format code (if needed)'
        id: format
        run: |
          # Run formatter and capture if any changes were made
          dotnet format --verbosity minimal --report .format-report.json || true
          
          # Check if any files were formatted
          if [ -f .format-report.json ]; then
            FORMATTED_FILES=$(jq -r '.DocumentsFormatted // 0' .format-report.json)
            if [ "$FORMATTED_FILES" -gt 0 ]; then
              echo "files-formatted=true" >> $GITHUB_OUTPUT
              echo "? Auto-formatted $FORMATTED_FILES files"
              
              # Configure git for auto-commit (only on push, not PR)
              if [ "${{ github.event_name }}" = "push" ]; then
                git config --local user.email "action@github.com"
                git config --local user.name "GitHub Action"
                git add .
                git commit -m "?? Auto-format code [skip ci]" || true
                git push || true
                echo "? Auto-formatting committed"
              else
                echo "??  Formatting needed but skipped on PR - please run 'dotnet format' locally"
              fi
            else
              echo "files-formatted=false" >> $GITHUB_OUTPUT
              echo "? Code already properly formatted"
            fi
          else
            echo "files-formatted=false" >> $GITHUB_OUTPUT
            echo "? No formatting report generated"
          fi
          
      - name: '?? Detect changes'
        id: changes
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

  # Job 2: Fast testing with coverage
  test:
    name: '?? Test & Coverage'
    runs-on: ubuntu-latest
    needs: build
    # Skip if auto-formatting was applied to avoid duplicate runs
    if: needs.build.outputs.files-formatted != 'true' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: '?? Checkout'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: '?? Setup .NET'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          
      - name: '?? Cache .NET packages'
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-
            
      - name: '?? Restore dependencies'
        run: dotnet restore --locked-mode
        
      - name: '?? Build for testing'
        run: |
          dotnet build --no-restore --configuration Release \
            /p:ContinuousIntegrationBuild=true \
            /p:Deterministic=true \
            /p:RunAnalyzersDuringBuild=false
            
      - name: '?? Run tests with coverage'
        run: |
          dotnet test \
            --no-build \
            --configuration Release \
            --logger "console;verbosity=normal" \
            --collect:"XPlat Code Coverage" \
            --results-directory ./tests/TestResults \
            --settings ./tests/FastGeoMesh.Tests/coverlet.runsettings \
            /p:CollectCoverage=true \
            /p:CoverletOutputFormat=lcov,opencover,cobertura \
            /p:CoverletOutput=./tests/TestResults/coverage/ \
            /p:UseSourceLink=true \
            /p:Threshold=70 \
            /p:ThresholdType=line,branch,method \
            /p:ThresholdStat=total
            
      - name: '?? Process coverage files'
        run: |
          # Find and organize coverage files
          find ./tests/TestResults -name "coverage.cobertura.xml" -exec cp {} ./tests/TestResults/coverage/ \; 2>/dev/null || true
          find ./tests/TestResults -name "coverage.opencover.xml" -exec cp {} ./tests/TestResults/coverage/ \; 2>/dev/null || true
          find ./tests/TestResults -name "coverage.info" -exec cp {} ./tests/TestResults/coverage/ \; 2>/dev/null || true
          
          # Ensure coverage.info exists for Codecov
          if [ ! -f "./tests/TestResults/coverage/coverage.info" ]; then
            echo "Creating placeholder coverage.info file"
            touch ./tests/TestResults/coverage/coverage.info
          fi
          
          # List all coverage files for debugging
          echo "Coverage files found:"
          find ./tests/TestResults -name "*coverage*" -type f 2>/dev/null | head -10 || echo "No coverage files found"
          
      - name: '?? Upload test results'
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: ./tests/TestResults/
          retention-days: 30
          
      - name: '?? Upload coverage to Codecov'
        uses: codecov/codecov-action@v4
        if: success()
        with:
          file: ./tests/TestResults/coverage/coverage.info
          flags: unittests
          name: fastgeomesh-coverage
          fail_ci_if_error: false
          verbose: false
          token: ${{ secrets.CODECOV_TOKEN }}
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  # Job 3: Security validation (light)
  security:
    name: '?? Security'
    runs-on: ubuntu-latest
    needs: build
    if: needs.build.outputs.files-formatted != 'true' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: '?? Checkout'
        uses: actions/checkout@v4
        
      - name: '?? Setup .NET'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          
      - name: '?? Security audit'
        run: |
          dotnet list package --vulnerable --include-transitive 2>&1 | tee security-audit.log
          if grep -q "has the following vulnerable packages" security-audit.log; then
            echo "? Vulnerable packages detected"
            cat security-audit.log
            exit 1
          else
            echo "? No vulnerable packages detected"
          fi

  # Job 4: Package (only on main/tags)
  package:
    name: '?? Package'
    runs-on: ubuntu-latest
    needs: [build, test, security]
    if: needs.build.outputs.should-deploy == 'true' && needs.build.outputs.files-formatted != 'true'
    
    steps:
      - name: '?? Checkout'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: '?? Setup .NET'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          
      - name: '?? Create NuGet package'
        run: |
          dotnet pack src/FastGeoMesh/FastGeoMesh.csproj \
            --configuration Release \
            --output ./packages \
            /p:PackageVersion=1.1.0-ci.$(date +%Y%m%d).$(git rev-parse --short HEAD) \
            /p:ContinuousIntegrationBuild=true \
            /p:RunAnalyzersDuringBuild=false
            
      - name: '?? Upload packages'
        uses: actions/upload-artifact@v4
        with:
          name: nuget-packages
          path: ./packages/
          retention-days: 90