# ?? Enhanced GitHub Actions workflow for FastGeoMesh .NET 8
# Optimized for performance and robust code formatting

name: 'CI/CD Enhanced'

on:
  push:
    branches: [ main, develop, 'feature/**', 'chore/**' ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_DETERMINISTIC_SOURCE_PATHS: true
  DOTNET_NOLOGO: true

jobs:
  # Job 1: Build and Format Check
  build:
    name: '?? Build & Format Check'
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
      format-needed: ${{ steps.format-check.outputs.format-needed }}
    
    steps:
      - name: '?? Checkout'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Required for auto-formatting commits
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: '?? Setup .NET'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          
      - name: '?? Cache .NET packages'
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-
            
      - name: '?? Restore dependencies'
        run: dotnet restore --locked-mode
        
      - name: '?? Build solution'
        run: |
          dotnet build --no-restore --configuration Release \
            /p:TreatWarningsAsErrors=false \
            /p:ContinuousIntegrationBuild=true \
            /p:Deterministic=true \
            /p:RunAnalyzersDuringBuild=false
            
      - name: '?? Check code formatting'
        id: format-check
        run: |
          echo "?? Checking code formatting..."
          
          # Run format check and capture result
          if dotnet format --verify-no-changes --verbosity minimal; then
            echo "? Code is properly formatted"
            echo "format-needed=false" >> $GITHUB_OUTPUT
          else
            echo "?? Code formatting issues detected"
            echo "format-needed=true" >> $GITHUB_OUTPUT
            
            # Show what would be formatted (for PR comments)
            echo "Files that need formatting:"
            dotnet format --dry-run --verbosity normal || true
          fi
          
      - name: '?? Auto-format code (push only)'
        if: steps.format-check.outputs.format-needed == 'true' && github.event_name == 'push'
        run: |
          echo "?? Auto-formatting code..."
          
          # Apply formatting
          dotnet format --verbosity minimal
          
          # Check if any files were actually changed
          if git diff --quiet; then
            echo "? No changes after formatting"
          else
            echo "?? Files were formatted, committing changes..."
            
            # Configure git
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            
            # Commit formatted files
            git add .
            git commit -m "?? Auto-format code [skip ci]"
            git push
            
            echo "? Auto-formatting committed"
          fi
          
      - name: '? Fail on format issues (PR only)'
        if: steps.format-check.outputs.format-needed == 'true' && github.event_name == 'pull_request'
        run: |
          echo "? Code formatting issues detected in PR"
          echo "Please run 'dotnet format' locally and commit the changes"
          echo ""
          echo "Or use the provided script:"
          echo "  ./scripts/format-code.ps1 -Fix   # Windows"
          echo "  ./scripts/format-code.sh --fix   # Linux/macOS"
          exit 1
          
      - name: '?? Determine deployment'
        id: changes
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

  # Job 2: Testing with coverage
  test:
    name: '?? Test & Coverage'
    runs-on: ubuntu-latest
    needs: build
    if: needs.build.outputs.format-needed != 'true' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: '?? Checkout'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: '?? Setup .NET'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          
      - name: '?? Cache .NET packages'
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-
            
      - name: '?? Restore dependencies'
        run: dotnet restore --locked-mode
        
      - name: '?? Build for testing'
        run: |
          dotnet build --no-restore --configuration Release \
            /p:ContinuousIntegrationBuild=true \
            /p:Deterministic=true \
            /p:RunAnalyzersDuringBuild=false
            
      - name: '?? Run tests with coverage'
        env:
          CI: true
        run: |
          dotnet test \
            --no-build \
            --configuration Release \
            --logger "console;verbosity=normal" \
            --collect:"XPlat Code Coverage" \
            --results-directory ./tests/TestResults \
            --settings ./tests/FastGeoMesh.Tests/coverlet.runsettings \
            -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=lcov,opencover,cobertura
            
      - name: '?? Process coverage files'
        run: |
          # Create coverage directory
          mkdir -p ./tests/TestResults/coverage/
          
          # Find and copy coverage files
          find ./tests/TestResults -name "coverage.cobertura.xml" -exec cp {} ./tests/TestResults/coverage/ \; 2>/dev/null || true
          find ./tests/TestResults -name "coverage.opencover.xml" -exec cp {} ./tests/TestResults/coverage/ \; 2>/dev/null || true
          find ./tests/TestResults -name "coverage.info" -exec cp {} ./tests/TestResults/coverage/ \; 2>/dev/null || true
          
          # Generate coverage.info if missing
          if [ ! -f "./tests/TestResults/coverage/coverage.info" ]; then
            echo "Creating coverage.info from available coverage files..."
            # Try to find any lcov file
            LCOV_FILE=$(find ./tests/TestResults -name "*.info" | head -n 1)
            if [ -n "$LCOV_FILE" ]; then
              cp "$LCOV_FILE" ./tests/TestResults/coverage/coverage.info
            else
              echo "SF:dummy" > ./tests/TestResults/coverage/coverage.info
              echo "end_of_record" >> ./tests/TestResults/coverage/coverage.info
            fi
          fi
          
          # List coverage files for debugging
          echo "Coverage files found:"
          find ./tests/TestResults -name "*coverage*" -type f | head -10
          
      - name: '?? Upload test results'
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: ./tests/TestResults/
          retention-days: 30
          
      - name: '?? Upload coverage to Codecov'
        uses: codecov/codecov-action@v4
        if: success()
        with:
          directory: ./tests/TestResults/
          flags: unittests
          name: fastgeomesh-coverage
          fail_ci_if_error: false
          verbose: true
          token: ${{ secrets.CODECOV_TOKEN }}

  # Job 3: Security scan
  security:
    name: '?? Security'
    runs-on: ubuntu-latest
    needs: build
    if: needs.build.outputs.format-needed != 'true'
    
    steps:
      - name: '?? Checkout'
        uses: actions/checkout@v4
        
      - name: '?? Setup .NET'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          
      - name: '?? Security audit'
        run: |
          dotnet list package --vulnerable --include-transitive 2>&1 | tee security-audit.log
          if grep -q "has the following vulnerable packages" security-audit.log; then
            echo "? Vulnerable packages detected"
            cat security-audit.log
            exit 1
          else
            echo "? No vulnerable packages detected"
          fi

  # Job 4: Package creation
  package:
    name: '?? Package'
    runs-on: ubuntu-latest
    needs: [build, test, security]
    if: needs.build.outputs.should-deploy == 'true' && needs.build.outputs.format-needed != 'true'
    
    steps:
      - name: '?? Checkout'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: '?? Setup .NET'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          
      - name: '?? Create NuGet package'
        run: |
          dotnet pack src/FastGeoMesh/FastGeoMesh.csproj \
            --configuration Release \
            --output ./packages \
            /p:PackageVersion=1.1.0-ci.$(date +%Y%m%d).$(git rev-parse --short HEAD) \
            /p:ContinuousIntegrationBuild=true \
            /p:RunAnalyzersDuringBuild=false
            
      - name: '?? Upload packages'
        uses: actions/upload-artifact@v4
        with:
          name: nuget-packages
          path: ./packages/
          retention-days: 90